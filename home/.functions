# Run tests
function p() {
   if [ -f vendor/bin/pest ]; then
      vendor/bin/pest "$@"
   else
      vendor/bin/phpunit "$@"
   fi
}

function pf() {
   if [ -f vendor/bin/pest ]; then
      vendor/bin/pest --filter "$@"
   else
      vendor/bin/phpunit --filter "$@"
   fi
}

# Create a new directory and enter it
function mkd() {
   mkdir -p "$@" && cd "$@"
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

function removehost() {
   ssh-keygen -R "$1"
}

#  Commit everything
function commit() {
  commitMessage="$*"

  git add .

  if [ "$commitMessage" = "" ]; then
     # Start spinner in background (suppress job control messages)
     {
       spinner="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
       while true; do
         for (( i=0; i<${#spinner}; i++ )); do
           printf "\r${spinner:$i:1} Generating commit message..."
           sleep 0.1
         done
       done
     } &!
     spinner_pid=$!

     # Cleanup function for interrupt
     cleanup() {
       { kill $spinner_pid; wait $spinner_pid; } 2>/dev/null
       printf "\r\033[K"
       trap - INT
       return 1
     }
     trap cleanup INT

     # Get diff with size limit, include stat summary for context
     diff_input=$(echo "=== Summary ===" && git diff --cached --stat && echo -e "\n=== Diff (truncated if large) ===" && git diff --cached | head -c 50000)
     commitMessage=$(echo "$diff_input" | claude -p "Write a single-line commit message for this diff. Output ONLY the message, no quotes, no explanation, no markdown.")

     # Stop spinner and clear line
     trap - INT
     { kill $spinner_pid; wait $spinner_pid; } 2>/dev/null
     printf "\r\033[K"

     git commit -m "$commitMessage"
     return
  fi

  eval "git commit -a -m '${commitMessage}'"
}

function db() {
    case "$1" in
        refresh)
            mysql -uroot -e "drop database $2; create database $2"
            ;;
        create)
            mysql -uroot -e "create database $2"
            ;;
        drop)
            mysql -uroot -e "drop database $2"
            ;;
        list)
            mysql -uroot -e "show databases" | sed 's/[|[:space:]]//g'
            ;;
        *)
            echo "Usage: db {refresh|create|drop|list} [database_name]"
            return 1
            ;;
    esac
}

function scheduler() {
   while :; do
      php artisan schedule:run
      echo "Sleeping 60 seconds..."
      sleep 60
   done
}

function git-prune-local() {
  echo "Finding local branches without remote counterparts..."
  
  # Get all local branches except main/master
  local_branches=$(git branch --format='%(refname:short)' | grep -v "^main$\|^master$")
  
  # Get all remote branches without fetching
  remote_branches=$(git ls-remote --heads origin | sed 's/.*refs\/heads\///')
  
  branches_to_delete=()
  
  # Check each local branch if it exists on remote
  for branch in ${(f)local_branches}; do
    found=0
    for remote_branch in ${(f)remote_branches}; do
      if [[ "$branch" == "$remote_branch" ]]; then
        found=1
        break
      fi
    done
    if [[ $found -eq 0 ]]; then
      branches_to_delete+=("$branch")
    fi
  done
  
  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    echo "No branches to remove."
    return
  fi
  
  echo "Branches to be removed:"
  printf '%s\n' "${branches_to_delete[@]}"
  
  # Ask for confirmation
  read "REPLY?Are you sure you want to delete these branches? (y/N): "
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    for branch in "${branches_to_delete[@]}"; do
      git branch -D "$branch"
    done
    echo "Branches removed successfully."
  else
    echo "Operation cancelled."
  fi
}
